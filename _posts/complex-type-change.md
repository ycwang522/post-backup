---
title: unsigned char类型数运算过程中应当注意的一些问题
date: 2016-06-13 16:21:21
categories: C++
tags:
	- C
	- C++
	- 类型转换
---


牛客上刷题的时候，碰上了一道如下所示的题目：
```cpp
int main()
{
	unsigned char i = 1;
	i -= 4;
	printf(“the value of i is: % d”, i);
}
```
请问i的值是：

    A.253
    B.254
    C.255
    D.256

> 正确答案是：A：253

刚开始做这个题的时候没多大注意，普通的类型转换无符号数的加减。
然而，我选择的254是错误的。
<!-- more -->

在看题目下边网友的回答中，大多数的回答是说计算i-4之后结果为-3，最后printf输出%d输出的时候转换成10进制输出。
![](https://ituku.tk/di/EBEON/baidushurufa-2016-6-13-16-6-17.png)

我在边看回答的过程中，顺便将代码贴到编译器中一步一步调试了看了一下，结果发现，在执行完i-=4之后，i就已经是253了，而不是回答所说的-3.

通过查阅资料，这里涉及两点内容
- **整型提升**：[在表达式计算时，各种整型首先要提升为int类型，然后执行表达式的运算](https://zh.wikipedia.org/wiki/%E6%95%B4%E5%9E%8B%E6%8F%90%E5%8D%87)。
- **计算机中的减法运算**：[在计算机中，是将减法转换成加法来计算的。在计算时，将负数转换成对应的补码进行计算](http://blog.csdn.net/lida2003/article/details/6973469)。


因此，在计算i-=4的时候就已经发生了类型转换，由unsigned int转换成了int类型。
因而在计算完i-=4这一步以后i的值就已经是253了，而不是-3.
----

在计算 i-=4这一步时，会发生如下转换：
实际计算的是 i+(-4)的计算。
i=1     ：0000 0001
-4作为负数，在计算机中是以补码的形式参与运算。
[ -4 ]原=1000 0100
[ -4 ] 反 =1111 1011
[ -4 ] 补 =1111 1100

在计算时，以下两个值进行相加：
i=1:     0000 0001
-4：    1111 1100
相加之和是：1111 1101
即：253





