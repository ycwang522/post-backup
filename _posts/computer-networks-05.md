---
title: 计算机网络（五）：运输层
date: 2016-07-09 17:56:30
categories: 计算机网络
tags:
	- TCP
	- UDP
---
# 运输层协议概述

## 进程之间的通信

**运输层向它上面的应用层提供通信服务。**它属于面向通信部分的最高层，同时也是属于用户功能的最底层。

> 网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三次的功能。

从IP层来说，通信的两个端机是两个主机。

严格讲，通信的实体是两个主机中的进程。

IP协议虽然通过源地址和目的地址进行通信，将分组送到目的主机，但是**这个分组停留在主机的网络层而没有交付给主机中的应用进程。**，所以从运输层的角度来看，**通信的真正端点并不是主机而是主机中的进程。**

运输层一个很重要的功能：
- 复用（multiplexing）：指在发送方不同的应用进程都可以使用同一个运输层协议传送数据
- 分用（demultiplexing）：接收方的运输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。

<!-- more -->

**运输层提供应用进程间的逻辑通信**：表示运输层之间的通信好像是沿着水平方向传送数据。但事实上运输层并没有一条水平方向的物理连接。要传送的数据是沿着多个层次传送的。

网络层和运输层之间的区别：
- 网络层为<font color="green">**主机之间**</font>提供逻辑通信
- 运输层为<font color="red">**应用进程之间**</font>提供端到端的逻辑通信

根据应用程序的不同需求，运输层需要有两种不同的运输协议，即**面向连接的TCP和无连接的UDP**。

运输层向高层用户屏蔽了下面网络核心的细节，使应用进程看见的就是好像在两个运输层实体之间有一条端到端逻辑通信信道。
- 运输层采用面向连接的TCP协议时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。
- 采用UDP协议时，仍然是一条不可靠信道。

## 传输层的两个主要协议

1. 用户数据报协议UDP（User Datagram Protocol）：UDP用户数据报。传送数据时不需要先建立连接。
2. 传输控制协议TCP（Transmission Control Protocol）：TCP报文段。数据传送前必须建立连接，传输结束后释放连接。

协要议端口号:端口。虽然通信的终点是应用进程，但我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作就由TCP来完成。

> 由此可见，两个计算机要进行通信，不但要知道对方的IP地址（为了找到对方的计算机），还需要知道对方的端口号（找到对方的计算机中的应用进程）

### TCP 和UDP的区别：
TCP和UDP都是一种常用的通信方式，在特定的条件下发挥不同的作用，具体而言，两者的区别主要表现在以下几个方面：
- <font color="green">TCP是面向连接的传输控制协议，而UDP提供的是无连接的数据报服务。</font>
- TCP具有高可靠性，确保传输数据的正确性，不出现丢失或乱序；UDP传输时，不建立连接，不对数据报进行检查与修改，无需等待对方的应答，可能会出现分组丢失、重复、乱序等情况。
- TCP对系统资源要求较多，UDP反之。
- <font color="green">UDP具有较好的实时性，工作效率比TCP高。</font>
- UDP的段结构比TCP段结构简单，因此网络开销也小。


# 用户数据报协议UDP

UDP只在IP的数据报服务之上增加了很少一点的功能，这就是<font color="green">复用和分用的功能以及差错检测的功能</font>。
UDP的主要特点有：

- **UDP是无连接的**。发送数据前不需要建立连接
- **UDP使用最大努力交付**
- UDP是面向报文的。UDP一次交付一个完整的报文。

![](https://ituku.tk/di/ZIUML/udpe-e-.png)
<center>**图1.UDP是面向报文的**</center>

- UDP没有阻塞控制
- UDP支持一对一，一对多和多对一的交互通信
- UDP首部开销小，只有8个字节，而TCP的首部为20个字节。

## UDP的首部格式

数据字段+首部字段

首部字段占用8个字节，包括四个字段，每个字段都是两个字节
- 源端口
- 目的端口
- 长度
- 检验和

![](https://ituku.tk/di/XDOZK/udp-ae-.png)
<center>**图2.UDP基于端口的分用**</center>

---

# 传输控制协议

## TCP最主要的特点

- 面向连接的传输层协议，使用前先建立连接。
- 每一条TCP只能有两个端点，每一条TCP连接只能是点对点的。
- 提供可靠交付的服务。无差错、不丢失、不重复、安旭到达。
- 全双工通信，通信双发的应用进程在任何时候都能发送数据。
- 面向字节流。“流”指流入进程或者从进程流出的字节序列。

## TCP的连接

每一条TCP连接有两个端点，**套接字（socket）或插口**。**端口号拼接到IP地址**即构成了套接字。

套接字的表示方法：点分十进制的IP地址后面写上端口号，中间使用冒号或者逗号隔开。
比如IP地址是192.3.4.5，而端口号是80.则套接字即为（192.3.4.5:80）。

**每一条TCP连接唯一地被通信两端的两个端点（两个套接字）所确定。**

	TCP连接::={socket1,socket2}={(IP1:port1),(IP2:port2)}

# 可靠传输的工作原理

## 停止等待协议

停止等待：每发送完一个分组就停止发送，等待对方确认。收到确认后再发送下一个分组。

![](https://ituku.tk/di/POILT/-e-.png)

<center>**图3.停止等待协议的无差错情况**</center>

### 传输出现差错的情况

B接收M1时检测出了问题，就直接丢弃M1，而不通知A。

可靠传输协议的设计思想是：
> A只要超过了一段时间仍然没收到确认，就认为刚才发送的分组丢失了，因而重新传送前面发送过的分组。这叫做超时重传。
> 通过设置超时计时器来完成。

![](https://ituku.tk/di/BHD3D/-e-1-.png)

<center>**图4.停止等待协议的超时重传情况**</center>

应该注意的几点：
- A发送完一个分组之后，必须暂时保留已发送分组的副本。只有确认后才能清除暂时保留的分组副本。
- 分组和确认分组都必须编号。
- 超时计时器设置的重传时间应当**比数据在分组传输的平均往返时间更长一些。**

### 确认丢失和确认迟到

确认丢失时，会重新传送该分组，分组到达B时：
- 丢弃这个重复的分组M1，不向上层交付
- 向A发送确认

确认迟到时，也会进行超时重传，并且会收下迟到的确认但什么也不会做。

基于以上的确认和重传机制，可以在**不可靠的传输网络上实现可靠的通信。**
像上述的这种可靠传输协议常常称为**自动重传请求ARQ**。

### 信道利用率

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。
流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就停顿下来等地对方确认。这样可使信道上一直有数据不间断地在传送。

# TCP报文段的首部格式

首部+数据两部分

TCP的全部功能都体现在它首部中各字段的作用。

TCP报文前20个字节是固定的，后面的4N个字节是根据需要而增加的。因此最小长度是20个字节。
包括以下部分：
- 源端口和目的端口，各占2个字节。
- 序号，占4个字节。
- 确认号
- 实际长度
- 保留
- 紧急URG。当URG=1时，表明紧急指针字段有效，提高优先级。
- 确认ACK（ACKnowledge）仅当ACK=1时确认号字段才有效。TCP规定，连接建立后所有传送的报文段都必须把ACK置为1.
- 推送PSH。
- 复位RST。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立运输连接。
- 同步SYN。在连接建立时用来同步序号。<font color="green">SYN=1而ACK=0时，表明这是一个链接请求报文段。对方若同意建立连接，则在相应的报文段中SYN=1和ACK=1。</font>因此，SYN置为1表示这是一个链接请求或链接接受报文。
- 终止FIN<font color="red">用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</font>

![](https://ituku.tk/di/XWD9E/qq-20160709155914.png)

<center>**图5.TCP报文段的首部格式**</center>



# TCP的运输连接管理

TCP是面向连接的协议。
运输连接是用来传送TCP报文的。
TCP运输连接的建立和释放时每一次面向连接的通信中必不可少的过程。

因此，运输连接就有三个阶段：<font color="green">**连接建立、数据传送、连接释放。**</font>

运输连接的管理就是使运输连接的建立和释放都能正常进行。

TCP连接建立过程中要解决三个问题：
- 使每一方都能确知对方的存在。
- 允许双方协商一些参数
- 能够对运输实体资源进行分配

TCP主动建立连接的应用进程叫做**客户（client）**，而被动等待连接建立的应用进程叫做**服务器（server）。**

## TCP的连接建立

![](https://ituku.tk/di/WHKKA/qq-20160709165024.png)
<center>**图6.用三次握手建立TCP连接**</center>

如上图，主机A运行TCP客户程序，B运行TCP服务器程序。
初始状态是两个进程都处于关闭状态。

A主动打开连接，B被动打开连接。

首先B的TCP服务器创建**传输控制块TCB**，准备接受客户进程的连接请求。服务器进程处于LISTEN状态，等待客户的连接请求。

- A的TCP客户端进程也先创建**传输控制块TCB**，然后向B发出连接请求报文段，<font color="red">此时同部位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段不能携带数据，但是消耗一个序号。完成之后，TCP客户进程进入SYN-SENT（同步已发送）状态</font>。
- B 收到连接请求报文段后，如果同意连接，则向A发送确认。确认报文段中应该把<font color="brown">SYN和ACK位都置1，确认号是ack=x+1，同时也为自己选择一个初始序号seq=y。这个报文段也不能携带数据，但消耗一个序号。完成后，TCP服务器进程进入SYN-RCVD（同步收到）状态。</font>
- TCP客户端进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1.此时，TCP建立，A进入ESTABLISHED(已建立连接)状态。

上面的连接建立过程叫做三次握手。

对于第三个过程——A发送确认——的解释：
> 主要是为了防止已失效的连接请求报文段突然又传送到了B而产生错误。——已失效连接主要由超时连接重发造成。


## TCP的连接释放

数据传输结束后，通信的双方都可以释放连接。
- A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。
A把连接释放报文段首部的FIN置1，其序号seq=u，u等于前面已经传送过的数据的最后一个字节的序号加1.
此时进入FIN-WAIT-1状态，等待B的确认。

- B收到连接释放报文后发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等于B前面已传送过的数据的最后一个字节的序号加1.然后B进入CLOSE-WAIT（关闭等待）状态。
TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接被释放，此时TCP处于**半关闭状态**，即A已经没有数据要发送了，但B若发送数据，A仍要接收。即B到A的连接并未关闭。
A收到B的确认后，就进入FIN-WAIT-2的状态，等待B发出的连接释放报文段。
- 若B没有向A发送的数据，其应用进程通知TCP释放连接。此时报文段的连接释放报文段必须使FIN=1.假定B的序列号为w。B还必须重复上次已发送过的确认号ack=u+1.这时B进入了LAST-ACK（最后确认）状态，等待A的确认。
- A在收到B的连接释放报文段后，必须对此发出确认。再确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1.然后进入到TIME-WAIT状态。现在TCP连接还没有是放电，必须经过**时间等待计时器**设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做**最长报文段寿命**，从A进入到TIME-WAIT状态后，经过2个MSL时间后才进入到CLOSED状态，才能开始建立下一个新的连接。当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。

![](https://ituku.tk/di/2J25Y/1.png)
<center>**图7.TCP连接释放的过程**</center>


**关于A的TIME-WAIT状态必须等待2MSL时间的解释**

- 为了保证A发送的最后一个ACK报文段能够到达B。在传输过程中，最后发送的确认信号ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到A已发送的FIN+ACK报文段的确认。这时，因为超时，<font color="green">B会重新传送FIN+ACK报文段。这样A就能在2MSL时间内收到这个重传的FIN+ACK报文段。接着A重传一个确认，同时启动2MSL计时器</font>。最后，AB都正常进入关闭状态。
- 防止“已失效的连接请求报文段”出现在本连接中。B只要收到了A的确认，就进入CLOSED状态。注意到**B结束TCP连接的时间要比A早一些。**