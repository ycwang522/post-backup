---
title: 类成员中调用delete this引发的错误解析
date: 2016-06-21 14:51:38
categories: C++
tags:
	- 析构
	- this指针
---

在类的成员函数中能不能调用delete this？
答案是肯定的，能调用，而且很多老一点的库都有这种代码。

假设这个成员函数名字叫delete_this，而delete this就在这个delete_this方法中被调用，那么这个对象在调用delete_this方法后，还能进行其他操作，如调用该对象的其他方法么？答案仍然是肯定 的，调用delete_this之后还能调用其他的方法，但是有个前提：**被调用的方法不涉及这个对象的数据成员和虚函数**。说到这里，相信大家都能明白为什么会这样 了。

根本原因在于**delete操作符的功能和类对象的内存模型**。

当一个类对象声明时，系统会为其分配内存空间。

<font color="brown">在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中</font>。

在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。

当调用`delete this`时，类对象的内存空间被释放。

<font color="brown">在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</font>

<!-- more -->

为什么是不可预期的问题？

`delete this`之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？

这个问题牵涉到操作系统的内存管理策略。

<font color="brown">delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。</font>
此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。
当你获取数据成员，可能得到的是一串很长的未初始化的随机数；
访问虚函数表，指针无效的可能性非常高，造成系统崩溃。

大致明白在成员函数中调用delete this会发生什么之后，再来看看另一个问题.

如果在类的析构函数中调用delete this，会发生什么？

实验告诉我们，会导致堆栈溢出。

原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存” (来自effective c++)。
显然，<font color="brown">delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</font>
--------------------我是分界面--------------------
上面是某大牛的分析，而在实际的运行过程中使用delele this确实会直接出现错误。

这是因为：在成员函数中调用delete this，首先会调用类的析构函数，this指针已删除，会出现指针错误。

下面是在XCode中使用delete this出现的错误：

    malloc: *** error for object 0xbffffa18: pointer being freed was not allocated

//注意0xbffffa18即为this的地址

    *** set a breakpoint in malloc_error_break to debug

而在VS2010中使用delete this是直接导致 Debug Assertion Failed！
具体的描述是：`invalid null pointer`


总结：
<font color="brown">在成员函数中调用delete this，会导致指针错误，而在析构函数中调用delete this，出导致死循环，造成堆栈溢出。</font>

PS：this是类中成员函数具有的一个附加的隐含形参，即指向该类对象的一个指针，它与调用成员函数的对象绑定在一起。

同时
- 在普通的非const成员函数中：this的类型是一个指向类类型的const指针，可以改变this指向的值，但是不能改变this所保存的地址；
- 在const成员函数中，this的类型是一个指向const类类型对象的const指针，既不能改变this所指向的对象，也不能改变this所保存的地址。


注意：
成员函数中不能定义this形参，而是由编译器隐含地定义，但是可以在成员函数中显式使用this形参，不过也不是必须这么做。如果对类成员的引用没有限定，编译器会将这种引用处理成通过this指针的引用。

有一种情况下必须显式使用this：**当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。**

从const成员函数返回`*this`：不能从const成员函数返回指向类对象的普通引用。const成员函数只能返回`*this`作为一个const引用。
