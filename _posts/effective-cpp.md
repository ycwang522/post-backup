---
title: Effective C++ 读书笔记
date: 2016-05-27 16:13:10
categories: C++
tags:
	- C++
---


* <h2>1 尽可能使用const</h2>

_________________


    如果const出现在星号左边，比如 `const int *p`，则说明被指向的对象是常量，

	即p指向的数据是常量，不允许赋值等运算；但是如果const出现在星号右边，

	比如`int *const p`，说明指针是是常量。如果出现在两边，说明两者都是常量。

_____________________

	
注：如果被指物是常量，有些程序员会将const写在类型前面，而有些人会将其写在类型后边，星号前边。均可。

<!-- more -->

___________________________________________________________


	STL迭代器的作用：类似于T *指针。
    
    声明迭代器为const就像声明指针为const一样，
    
    表明这个迭代器不得指向别的东西，但是其所指向的值是可以改变的。
    
    如果希望指向的值不发生改变，则需要的是const_iterator.

____________________________

const最具威力的用法是：

面对函数声明时，在一个函数声明式内，其可以和函数返回类型，各参数，函数自身产生关联。

const修饰类的成员函数：

在类中，类的成员函数后边加const，<font color="red">表示这个成员函数不会对类对象的数组成员做任何修改</font>。

在设计类的时候，一个原则就是对于不改变数据成员的成员函数都要在后面加 const，而对于改变数据成员的成员函数不能加 const。所以 const 关键字对成员函数的行为作了更加明确的限定：<font color="red">有 const 修饰的成员函数（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；没有 const 修饰的成员函数，对数据成员则是可读可写的。</font>


_______________


* <h2>2 static静态变量的用法</h2>

static变量只能初始化一次：

```cpp
<?cpp

#include<stdio.h>

void fun(int i)
{
	static int value = i++;
	printf("%d\n", value);
}

int main()
{

	fun(5);
	fun(1);
	fun(2);

	return 0;
}
//执行该程序之后输出为0,0,0.
//因为value是静态变量，只会定义一次，不管fun函数被调用多少次，以后调用该函数时，`static int value=i++`不再执行。

?>
```
____________
如下的例子：

```cpp
<?cpp

#include<stdio.h>

void fun(int i)
{
	static int value = i++;
	value = i++;
	printf("%d\n", value);
}

int main()
{

	fun(5);
	fun(1);
	fun(2);
	return 0;
}
//输出为：6,1,2.

?>
```
* <h2>3 引用</h2>

转载自：[Mr.xu的博客](http://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html)

### 3.1 引用简介

　引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。
　引用的声明方法：**类型标识符 &引用名=目标变量名**；

【例1】：`int a; int &ra=a;` //定义引用ra,它是变量a的引用，即别名
　　
说明：

- &在此**不是求地址运算，而是起标识作用**。
- 类型标识符是指目标变量的类型。
- 声明引用时，必须同时对其进行**初始化**。
- 引用声明完毕后，**相当于目标变量名有两个名称**，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
　　 ra=1; 等价于 a=1;
- 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
- 不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

_______________

### 3.2 引用的应用

1> 引用作为参数

　　引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为 这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引用。
 
【例2】：

```
void swap(int &p1, int &p2) //此处函数的形参p1, p2都是引用
{ 
	int p; 
	p=p1; 
	p1=p2; 
	p2=p; 
}
```

　　
　　为在程序中调用该函数，则相应的主调函数的调用点处，**直接以变量作为实参进行调用即可，而不需要实参变量有任何的特殊要求**。如：对应上面定义的swap函数，相应的主调函数可写为：

```cpp
<?cpp

main( )
{
　int a,b;
　cin>>a>>b; //输入a,b两变量的值
　swap(a,b); //直接以变量a和b作为实参调用swap函数
　cout<<a<< ' ' <<b; //输出结果
}

?>
```
上述程序运行时，如果输入数据10 20并回车后，则输出结果为20 10。

	由【例2】可看出：

- 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。
　　
- **使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作**；而使用一般变量传递函数的参数，当发生函数调用时，需要给 形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，**当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好**。
　　
- **使用指针作为函数的参数虽然也能达到与使用引用的效果**，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的 形式进行运算，这很容易产生错误且程序的阅读性较差；**另一方面，在主调函数的调用点处，必须用变量的地址作为实参**。而引用更容易使用，更清晰。　　

　　如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。

______________

### 3.3 常引用

　　常引用的格式为：const 变量标识符 & 引用名=目标变量名

　　用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。
	
【例3】：有如下代码

```
int a ;
const int &ra=a;//const引用，不能通过引用对目标的值进行修改
ra=1; //错误
a=1; //正确
```

这不光是让代码更健壮，也有些其它方面的需要。

【例4】：假设有如下函数声明：

```
string foo( );
void bar(string & s);

//那么下面的表达式将是非法的：

bar(foo( ));
bar("hello world");

```

    原因在于foo( )和"hello world"串都会产生一个临时对象，
    
    而在C++中，这些临时对象都是const类型的。因此上面的表达式就是试图
    
    将一个const类型的对象转换为非const类型，这是非法的。
　　
<font color="red">引用型参数应该在能被定义为const的情况下，尽量定义为const 。</font>

### 3.4 引用作为返回值

要以引用返回函数值，则函数定义时要按以下格式：

	    类型标识符 &函数名（形参列表及类型说明）
    	{
    		函数体；
    	}

说明：

　　（1）以引用返回函数值，定义函数时需要在函数名前加&。

　　（2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。
	
	例[5]，有如下代码:
	

```cpp
<?cpp

#include<iostream>
float temp;//定义全局变量
float fn1(float r);//fn2函数声明   	以返回函数值得方式返回函数值
float fn2(float r);//fn2函数声明

float fn1(float r)	//fn1函数，以返回函数值的方式返回函数值
{
	temp=(float)(r*r*3.14);
	return temp;
}

float fn2(float r)
{
	temp=(float)(r*r*3.14);
	return temp;
}

void main()
{
	float a=fn1(10.0);//第1种情况，系统生成要返回值的副本（即临时变量）
	float &b=fn1(10.0);//第2种情况，可能会出错（不同 C++系统有不同规定）
　//不能从被调函数中返回一个临时变量或局部变量的引用	
	float c=fn2(10.0); //第3种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
	float &d=fn2(10.0);//第4种情况，系统不生成返回值的副本
　//可以从被调函数中返回一个全局变量的引用
	std::cout<<a<<" "<<c<<" "<<d<<std::endl;
}

?>
```

### 3.5 枚举变量值的计算


```
#include<stdio.h>
int main()
{
	enum(a,b=5,c,d=4,e);
	printf("%d %d %d %d %d",a,b,c,d,e);
	return 0;
}
//程序执行之后，输出：0,5,6,4,5.
```
	分析：在枚举中，某个枚举变量的值默认为前一个的值加1，
	如果第一个枚举变量没有被赋值，则默认为0.