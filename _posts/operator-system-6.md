---
title: 操作系统学习（六）：基本内存管理
date: 2016-07-03 16:58:22
categories: 操作系统
tags:
	- 操作系统
	- 内存管理
---


内存管理的两个目标：

- 地址保护：一个进程不能随意访问另一个程序地址空间

- 地址独立：程序发出的地址应与物理主存地址无关
 
针对第二条`地址独立`做一些说明：

> 程序在加载到内存中然后执行一条条的指令。
指令执行时需要读取操作数和写入运算结果。
而读取操作数是通过地址来寻址，这个地址不能是物理地址。
因为不能确定程序可能会在什么配置的机子上运行，每个机子的物理地址不同。
所以读取操作数的地址应该是程序发出的一个虚拟地址，这个地址是与具体的硬件无关的。
（<font color="green">程序可以跨平台，与硬件配置无关）</font>

## 虚拟内存

虚拟内存的中心思想是将主存扩大到便宜，大容量的磁盘上，将磁盘看作主存的一部分。

内存管理系统的中心功能：对程序所在位置（主存，缓存，磁盘）的判断

<!-- more -->

## 单道程序的内存管理

**静态地址翻译**：内存中只有两个程序，操作系统和用户程序。操作系统每次定位到同一个地方来启动用户程序，这样用户程序里面的地址都可以事先计算出来，运行前就计算出所有物理地址。称之为静态地址翻译

## 多道程序的内存管理

动态地址翻译：程序运行时进行地址翻译

- **固定分区**：
	- 所有用户程序排成一列等到分区中的程序执行，有空缺则队列前边的程序补上(如图1所示)
	- 按照程序大小排成不同的队列等候在不同的分区后边（如图2所示）
	- 地址翻译的方法：物理地址=虚拟地址+程序所在区域起始地址(基址)
- **非固定分区的内存管理**：除了划分给操作系统的空间外，其余的内存空间是作为一个整体存在的。

非固定分区的缺点：每个程序像叠罗汉一样累计，如果该程序需要更多空间则无法再重新分配。
针对非固定分区缺点的解决办法：在给每个程序分配空间时留有一定的增长空间。如图3所示。

![共享队列的固定分区](https://ituku.tk/di/5OEA4/-.png)

<center>**图1.共享队列的固定分区**</center>

![分开队列的固定分区](https://ituku.tk/di/9VLLS/-1-.png)

<center>**图2.分开队列的固定分区**</center>

虚拟内存的根本是将内存扩展到磁盘上，将磁盘当成是内存的一部分。

![程序执行过程中的空间增长](https://ituku.tk/di/W9201/-2-.png)
<center>**图3.程序执行过程中的空间增长**</center>

<center>![数据和栈的生长方式](https://ituku.tk/di/CBNH4/-3-.png)</center>

<center>**图4.数据和栈的生长方式**</center>