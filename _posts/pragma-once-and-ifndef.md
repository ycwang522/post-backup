---
title: pragma once与#ifndef
date: 2016-07-23 22:14:00
categories: 数据结构
tags:
	- pragma once
	- idndef
---


##  #ifndef

''#ifndef'这种是最早期使用的方法，是基于语言的宏定义名字不能冲突的前提下的。

<font color="green">这种方法不仅能保证同一个头文件不会被包含两次，也可以保证内容完全相同的两个文件也只能被包含一次。</font>

<font color="brown">但是他也有缺点，就是你的#ifndef 后面跟的宏名字和你程序中的其他宏名字发生了”撞车“，那么会出现以下两种后果</font>

### 第一种：程序包含的file1头文件中有一个宏

```c++
//file1.h
#define BOOK_H   //宏名
```

现在又有一个文件 `book.h` 里面使用了宏定义方式防止头文件二次编译，而且定义防止二次编译的宏名和另一个头文件中的宏名相同，如下所示：

```c++
//book.h
#ifndef BOOK_H
#define BOOK_H
//  program codes
#endif
```

<!-- more -->
下面是你的主函数所在文件内容

```c++
#include"fil1.h"	//其中包含宏BOOK_H
#include"book.h"   //在该文件的语句中，会探测到已经包含了宏BOOK_H，于是不再包含这个头文件。
//这两个都是你自己的头文件
#include<........>
//..................
```

预编译阶段把file1文件展开，就得到了宏 `BOOK_H`，在处理`book.h`文件时就发现`BOOK_H`这个宏已经存在了，就不会包含`book.h`头文件了，这就是弊端所在了。

### 第二种

两者顺序反过来了，弊端类似。

`#pragma once`这种方式，是微软编译器独有的，也是后来才有的，所以知道的人并不是很多，用的人也不是很多，因为他不支持跨平台。如果你想写跨平台的代码，最好使用上一种。这是一种由编译器提供支持的方式，防止同一文件的二次编译，这里的同一文件指的是物理文件。

他也是有弊端的：

假如你的某一个头文件有多份拷贝，那么这些文件虽然在逻辑上都是一样的，但是在物理上他们却是不同的，所以当你把这些文件包含的时候，就会发现真的都包含进来了，然后就是编译错误了。还有，当物理上的同一文件被嵌套包含的时候，使用第一种方法预处理会每一次打开该文件做判断的，但是第二种方法则不会，所以在此`#pragma once` 会更快些。下面举例说明

预处理器在执行这四句的时候，先打开Test1.h然后发现里面的宏TEST1_H没有被定义，所以会包含这个文件，第二句的时候，同样还是会打开Test2.h的发现宏已定义，就不包含该文件按了。第三句时，发现之前没有包含Test2,h则会把该文件包含进来，执行第四句的时候，发现该文件已经被包含了，所以不用打开就直接跳过了。



## 总结：

## 方式一由语言支持所以移植性好，方式二 可以避免名字冲突





- 转自：http://blog.csdn.net/zlhy_/article/details/8192580
